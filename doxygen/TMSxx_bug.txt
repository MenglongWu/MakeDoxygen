// TMSxxTC bug记录
/*! \page bug123 abc
 intruction
 \code {.cpp}
 add code
 \endcode
*/

/*! \page commit-2015-04-27 "liwjkjkjei"
	ffffffff
*/


/*! \page commit-20xx-xx-xx brief
	intruction
	\code {.cpp}
	add code
	\endcode
*/


/*! \page commit-2015-06-28-3 fix trace网管连接后，trace端先关闭，MCU端崩溃
	- \subpage commit-2015-06-28-2

	修改 epFUI_OnRemoveClose 处理流程
	\code {.cpp}
	PrintConnectRemoveInf
	tms_RemoveDev(pnode->sockfd);
	tms_DelManage(pnode->sockfd);
	改成
	tms_DelManage(pnode->sockfd);
	PrintConnectRemoveInf
	tms_RemoveDev(pnode->sockfd);
	\endcode

	- 方法2

	截获 SIGPIPE 消息自己处理，但是这种方式也判断不出参数 SIGPIPE 的原因
	\code {.cpp}
	void sig_handler(int sig)
	{
		perror("what:");
	}
	main()
	{
		signal(SIGPIPE, sig_handler);
	}
	\endcode	

	运行结果
	\code {.cpp}
	----OnRemoveClose----
	       5       127.0.0.1:6500    ---xx       127.0.0.1:33650   2015-6-28 13:53:57
	what:: Success
	-------tms_DelManage--------   5

	MiniShell:>
	\endcode	

*/


/*! \page commit-2015-06-28-2 bug trace网管连接后，trace端先关闭，MCU端崩溃
问题在于，对于普通的连接关闭后，MCU要向trace发送调试信息，当普通连接变成trace连接，
在向一个关闭的socket发送数据时无效的。\n
对于阻塞的socket send失败将返回-1，但对一个异步socket send以后得不到错误码。最终程序
被系统抛出SIGPIPE终止，下面是将tms_Trace里的 glink_Send 用两个连续 send 代替，ret得不到
socket无效的提示。

\code {.cpp}
346             if(paddr == NULL) {
(gdb) n
347                     base_hdr.src = TMS_DEFAULT_LOCAL_ADDR;
(gdb) n
348                     base_hdr.dst = TMS_DEFAULT_RMOTE_ADDR;
(gdb) n
357             level = level & 0x3;
(gdb) n
371                     count = tms_GetTCManageFd(&fd);
(gdb) n
375                     glink_Build(&base_hdr, ID_TRACE0 + level, len);
(gdb) n
376                     int ret=0;
(gdb) n
377                     ret = send(fd[0],(uint8_t*)strout, 2,0);
(gdb) n
378                     printf("ret = %d\n", ret);
(gdb) n
ret = 2
379                     ret = send(fd[0],(uint8_t*)strout, 2,0);
(gdb) n

Program received signal SIGPIPE, Broken pipe.
0x40022416 in __kernel_vsyscall ()
(gdb) 
\endcode
*/



/*! \page commit-2015-07-03-1 bug/fix 当CU异常断开连接后，不能重新连接
	由于之前做的修改\subpage commit-2015-06-28-1 引发的缺陷，处理方式在检查CU确实断开
	调用ep_Close同时设置client.sockfd为0
	\code {.cpp}
	    if (g_en_connect_cu == 1 && 0 != client.sockfd) {
	    	struct tmsxx_app *ptapp = (struct tmsxx_app*)client.ptr;
			
			for (int i = 0;i < 10; i++) {
				tms_Tick(client.sockfd, NULL);
				sleep(3);

				if (ptapp->context.tick == 0) {
					if (i < 6) {
						printf("continue send TICK to cu %d\n",i);
						continue;
					}
					else {
						tms_SetCUFd(0);
						// tms_DelManage(client.sockfd); // 解决bug
						ep_Close(pep, NULL, client.sockfd);
						client.sockfd = 0;// 加上这一句
						break;
					}
				}
				else {
					break;
				}
			}
			ptapp->context.tick = 0;
	    }
	\endcode

*/
/*! \page commit-2015-06-28-1 fix trace网管不经过CU连接MCU导致MCU服务器崩溃
	- \subpage commit-2015-06-28
	
	修补代码：
	\code {.cpp}
	// 添加初始化，防止某些编译器不初始化为全0
	bzero(&client, sizeof(struct ep_con_t));
	// 替换
	// if (g_en_connect_cu == 1 && 0 != tms_ManageCount()) {
	if (g_en_connect_cu == 1 && 0 != client.sockfd) {
	\endcode
	修改后的ThreadConnectCU
	\code {.cpp}
	void *ThreadConnectCU(void *arg)
	{
		struct ep_con_t client;
		

		bzero(&client, sizeof(struct ep_con_t));
		// return 0;
	#ifdef _MANAGE
		return 0;
	#endif
		usleep(3000000);//延时3s，防止x86下efence奔溃
		while(1) {
			if (g_en_connect_cu == 1 && 0 == tms_ManageCount()) {
				if (0 == ep_Connect(pep,&client, "192.168.0.253", 6000) ) {
			    }
			    else {
			    	sleep(5);
			    	continue;
			    }
		    }
		    // if (g_en_connect_cu == 1 && 0 != tms_ManageCount()) {
		    if (g_en_connect_cu == 1 && 0 != client.sockfd) {
		    	struct tmsxx_app *ptapp = (struct tmsxx_app*)client.ptr;
		    }

		}
	    

	}
 	\endcode
*/

/*! \page commit-2015-06-28 bug trace网管不经过CU连接MCU导致MCU服务器崩溃
	gdb core 查看错误信息,ptapp是空指针
	\code {.cpp}
	Core was generated by `./release/download.elf'.
	Program terminated with signal 11, Segmentation fault.
	#0  0x0804ec8f in ThreadConnectCU (arg=0x807a860) at src/tms_app.c:620
	620                                     if (ptapp->context.tick == 0) {
	(gdb) p ptapp
	$1 = (tmsxx_app *) 0x0
	(gdb) 
	\endcode

	代码client.ptr是MCU主动连接CU的描述符，trace网管不经过CU连接MCU，连接成功后
	tms_ManageCount不为0，且client仍旧是无效连接，其ptr也不会再ep_app里被初始化，
	导致client.ptr为NULL
	\code {.cpp}
    if (g_en_connect_cu == 1 && 0 != tms_ManageCount()) {
	struct tmsxx_app *ptapp = (struct tmsxx_app*)client.ptr;
	
	for (int i = 0;i < 10; i++) {
		tms_Tick(client.sockfd, NULL);
		sleep(3);

		if (ptapp->context.tick == 0) {
			// ...
		}
	}
	\endcode


	
*/

/*! \page commit-2015-06-13-1 fix 解决 tms_AlarmHW 崩溃
	- \subpage commit-2015-06-13-0

	问题有2个
	-# tms_AlarmHW 错误发送命令码ID_RET_COMPOSITION，正确命令码是ID_ALARM_HW
	-# 由于发送命令码ID_RET_COMPOSITION，回调指针pf_OnRetDeviceComposition，
	回调函数tms_OnRetDeviceComposition，内部调用DispFrame

	DispFrame在 cmd_tmsxx.c 定义，为\n
	int DispFrame(struct tms_devbase *pframe, uint32_t flag, struct trace_cache *ptc)\n
	tms_OnRetDeviceComposition 在 tms_app.c 定义，声明为\n
	int DispFrame(struct tms_devbase *pframe, uint32_t flag)\n
	早起DispFrame没有ptc参数，多地方不同定义欺骗编译器。
	修改方法如下
	\code {.cpp}
	int DispFrame(struct tms_devbase *pframe, uint32_t flag, struct trace_cache *ptc)
	{
		if (ptc == NULL) {
			return -1;
		}
		ret = snprintf(ptc->strout + ptc->offset, ptc->empty - ptc->offset,
		"-------------------------------------------------\n");
		ptc->offset += ret;
	}
	\endcode
*/
/*! \page commit-2015-06-13-0 bug 调用 tms_AlarmHW 导致崩溃
	测试代码，输入tms a执行发送
	\code {.cpp}
	if (argc == 2 && strcmp(argv[1], "a") == 0) {
		struct tms_alarm_hw_val val;
		val.frame = 1;
		val.level = 2;
		val.slot = 3;
		strcpy((char*)val.reason, "abcefawerawe reason");
		strcpy((char*)val.time, "2015");
		tms_AlarmHW(sg_sockfdid, NULL, 1, &val);
	}
	\endcode
	程序崩溃，gdb定位程序停止在DispFrame，tms_AlarmHW 不应该引起DispFrame调用,崩溃点在
	ret = snprintf(ptc->strout + ptc->offset, ptc->empty - ptc->offset,
	\code {.cpp}
	int DispFrame(struct tms_devbase *pframe, uint32_t flag, struct trace_cache *ptc)
	{
		ret = snprintf(ptc->strout + ptc->offset, ptc->empty - ptc->offset,
		"-------------------------------------------------\n");
		ptc->offset += ret;
	}
 	\endcode
*/



/*! \page commit-2015-06-09 bug 当有自连接时scan all扫描崩溃
 	如果有127.0.0.1 6500 自连接 scan all 后弹出段错误\n
	位置定位到 tmsxx.c : tms_Analyse ，崩溃点在pwhichArr->ptrfun(pcontext, pdata, len);gdb检查ptrfun、以及3个参数均无非法访问，未果

	\code {.cpp}
	case PROCCESS_SPECAIAL:
		printf("specail help!!!!!!!\n");
		pwhichArr->ptrfun(pcontext, pdata, len);
		tms_Copy2Use(pcontext, pdata, len);
		break;
	\endcode
*/
/*! \page commit-2015-04-26 bug/fix STM32业务板在热插拔容易IP识别错误
	地址线配置错误，因为功能板启动太快所致，启动后稍作延时再读取地址线即可解决
*/
- 